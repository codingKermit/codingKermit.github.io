---
title: 리액트 맛보기 2일차
date: 2024-06-16
categories:
  - Front End
  - React
tags:
  - FrontEnd
  - React
  - 프론트엔드
  - 리액트
---
리액트 맛보기 2일차!

오늘의 공부 내용을 정리합니다.

## 01. prop
부모 컴포넌트가 자식 컴포넌트에게로 전달하는 값
이 prop을 통해 자식 컴포넌트를 상황에 맞게 커스터마이징 하여 사용할 수 있도록 설계할 수 있습니다.

ex)
```
const FirstBtn = (props) =>{
	<button>{props.text}</button>
}

const SecondBtn = ({text}) => {
	<button>{text}</button>
}

function App(){
	return(
		<FirstBtn text="This is First Button">
		<SeconBtn text="This is Second Button"
	)
}
```

위의 예시에서 사용한  예시로 `FirstBtn` 와 `SecondBtn` 컴포넌트가 있는데 두 번째 예시의 방법으
로 사용하는 것이 어떠한 prop을 사용할 것인지 명시적으로 사용하기 때문에 더 좋다고 생각합니다.  
두 번째 방법은 ES6의 문법을 응용한 방법입니다

###  02. memo
부모 컴포넌트에서 `<Btn/>` 이라는 자식 컴포넌트를 사용한다 가정할 때에, state에 따라 Btn을 다시 랜더링 하는 경우가 있습니다.
 이 때 특정한 하나의 `<Btn/>` 컴포넌트의 prop이 바뀌어 다시 랜더링 되는 경우 리액트에서는 모든 `<Btn/>` 컴포넌트를 다시 랜더링합니다.
 이렇게 된다면 화면 내에 `<Btn/>` 이라는 컴포넌트가 500개가 있다 가정하면 1개의 `<Btn/>` 컴포넌트를 다시 랜더링 하기 위해 500개의 컴포넌트를 랜더링 해야하는 문제가 발생하고 이는 속도를 느게 만드는 원인이 될 수 있습니다.
 이 것을 막기위해 있는 방법이 `memo()` 입니다. prop의 변화가 있지 않다면 랜더링을 하지 않도록 명시하는 기능을 합니다.
#### 개선 전
```
const Btn = ({index}) => {
	return (
		<button>{index}</button>
	)
}

const [index, setIndex] = useState(0);

const changeIndex = () => setIndex(900)

function App(){
	return(
		{/* prop의 변화가 생기는 하나의 컴포넌트*/}
		<Btn index={index}/>
		
		{/* prop의 변화가 생기지 않는 다수의 컴포넌트들 */}
		<Btn index={1}/>
		...생략
		<Btn index={500}/>
	)
}
```
위의 코드는 prop이 변하는 하나의 컴포넌트를 랜더링 하기 위해 아래의 500개의 컴포넌트도 랜더링 됩니다.

#### 개선 후
```
const Btn = ({index}) => {
	return (
		<button>{index}</button>
	)
}

const [index, setIndex] = useState(0);

const changeIndex = () => setIndex(900)

const MemoriezedBtn = memo(Btn);

function App(){
	return(
		{/* prop의 변화가 생기는 하나의 컴포넌트*/}
		<MemoriezedBtn index={index}/>
		
		{/* prop의 변화가 생기지 않는 다수의 컴포넌트들 */}
		<MemoriezedBtn index={1}/>
		...생략
		<MemoriezedBtn index={500}/>
	)
}
```
위의 코드는 prop이 변하는 첫 번째 컴포넌트를 제외한 나머지 컴포넌트는 다시 랜더링 되지 않습니다.
 
### 03. prop-Types
순수 자바스크립트에서 변수의 타입을 알 수 없듯이 리액트의 prop도 동일합니다.
어떤 컴포넌트의 개발자가 prop들을 어떤 타입으로 받기를 원하는지는 알 수 없습니다.
이 부분을 돕기 위한 라이브러리가 prop-types 입니다.
prop-types 라이브러리를 사용하여 prop의 타입을 명시하고 컴포넌트를 사용하는 개발자들에게 도움을 줄 수 있습니다.
```
const Btn = ({text, fontSize}) =>{
	return(
		<button 
			style={{
				fontSize : fontSize,
			}}
		>{text}</button>
	)
}

Btn.propTypes = {
	text : string,
	fontSize : number
}

function App(){
	return(
		<Btn text="This is String" fontSize={24}/>
		<Btn text="This is String" fontSize={"This is String"}/>
	)
}
```
위와 같은 코드는 컴파일 에러를 발생 시키지 않지만 개발자도구에서 에러를 발생시킵니다.

=> 에러 예시
> Failed prop type: Invalid prop `fontSize` of type `string` supplied to `Btn`, expected `number`.

Prop-Types 에서 사용되는 타입들은 공식 홈페이지에서 확인할 수 있습니다.

[https://legacy.reactjs.org/docs/typechecking-with-proptypes.html](https://legacy.reactjs.org/docs/typechecking-with-proptypes.html)
