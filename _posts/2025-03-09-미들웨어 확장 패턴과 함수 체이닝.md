---
title: 미들웨어 확장 패턴과 함수 체이닝
date: 2025-03-09
categories:
  - javascript
tags:
  - javascript
  - Node
---
안녕하세요 🐸  

미들웨어 확장패턴과 함수 체이닝에 대해 알아보고 정리하겠습니다  

## 함수 체이닝
함수를 연결하여 사용하는 방법 입니다.  
어떠한 리턴 값이 함수면 이어서 파라미터를 붙여주는 것으로 이어서 함수를 사용할 수 있습니다.  
예시로 아래와 같이 사용할 수 있습니다.  

```javascript
function middleware(test){
	console.log('test : ', test);
	return (req,res,next)=>{
		next();
	}
}

const test = 'boom!';
middleware(test)(req,res,next);
```

함수의 리턴 값이 함수이고 그 함수를 바로 호출 하는 형식이 익숙하지 않으면 했갈릴 수 있습니다.  
`map()` 함수는 배열에서 사용해서 특정한 배열을 리턴하고 배열에서 사용할 수 있는 함수를 이어서 쓸 수 있는데 이러한 구조에서 리턴 값이 배열이 아니라 함수로 바뀌었다 생각해보면 비교적 쉽게 이해가 됩니다.   

## 미들웨어 확장 패턴
미들웨어를 생성하고 이를 동적으로 체이닝하여 사용하는 방법입니다.  

```javascript
app.use(cors(/*옵션*/));

// 위 코드와 아래 코드는 기능적으로 동일
app.use((req,res,next)=>{
	cors(/*옵션*/)(req,res,next);
})
```

예시로 사용한 코드는 서로 동일하게 기능합니다.  
`use()` 는 미들웨어의 체이닝을 지원하기 때문에 위에서 명시적으로 미들웨어 확장 패턴을 사용하지 않아도 두 번째 코드와 같이 동작하는 것 입니다.  
`use()` 와 다르게 `get()` , `post()` 에서는 미들웨어의 체이닝을 자동으로 지원하지 않기 때문에 이를 해결하기 위해 미들웨어 확장 패턴을 명시적으로 구현하는 것 입니다.  
또한 미들웨어 확장 패턴의 구조를 보면 함수 체이닝의 예시와 구조가 같은 것을 알 수 있습니다. 이는 반환되는 함수가 미들웨어 함수이기 때문입니다.  
아래와 같은 예시에서 미들웨어는 정상적으로 동작하지 않습니다.  

```javascript
app.get('/',(req,res,next)=>{
cors(/*옵션*/);
next();
},(req,res,next)=>{
return res.status(200);
})
```

왜냐하면 `cors()` 는 미들웨어 함수를 리턴하기 때문입니다. 위의 예시에서는 함수를 리턴 받았지만 그 함수를 실행시키지는 않은 상태입니다.  
반면 아래의 함수는 유효합니다.

```javascript
app.get('/',(req,res,next)=>{
const corsFunc = cors(/*옵션*/); // 미들웨어 함수 생성
corsFunc(req,res,next); // 미들웨어 함수 호출
},(req,res,next)=>{
return res.status(200);
})
```

여기서는 미들웨어 확장 패턴과는 형식이 다르지만 여전히 동작합니다.  
미들웨어 확장 패턴은 곧 자바스크립트의 함수 체이닝을 사용한 방법이기 때문입니다.  